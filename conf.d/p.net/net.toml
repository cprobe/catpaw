[[partials]]
## ===== 最小可用示例（30 秒跑起来）=====
## 1) 在 instances.targets 里填 host:port
## 2) protocol 默认 tcp；如果是 udp，建议配 send + expect
## 例子：
## targets = ["127.0.0.1:22", "10.0.0.8:6379"]
## # protocol = "udp"
## # send = "ping"
## # expect = "pong"
## 常见误区：
## - UDP 不配置 send/expect 时，通常只能判断“端口可达”，难以判断“服务可用”
## - read_timeout 只有配置 expect 时才生效
## - targets 必须是 host:port 形式

id = "default"

## 每个 instance 并发探测数
# concurrency = 10

## 连接超时（默认 1s）
# timeout = "1s"

## 读超时（只有配置了 expect 时才有意义）
# read_timeout = "1s"

## 协议类型：必须是 "tcp" 或 "udp"
## 注意：UDP 天然无连接，通常需要配 send/expect 才能判断服务是否正常
# protocol = "tcp"

## 发送内容（UDP 建议必配；TCP 可选）
# send = "ssh"
## 期望返回内容（与 send 配合使用）
# expect = "ssh"

## 连通性检测（默认启用，默认 Critical）
## check 标签固定为 "net::connectivity"
[partials.connectivity]
severity = "Critical"
# title_rule = "[check] [target]"

## 响应时间检测（warn_ge 和 critical_ge 都为 0 则关闭）
## check 标签固定为 "net::response_time"
# [partials.response_time]
# warn_ge = "200ms"
# critical_ge = "1s"
# title_rule = "[check] [target]"


[[instances]]
## 目标地址列表，格式 host:port
targets = [
#     "127.0.0.1:22",
#     "localhost:6379",
#     ":9090"
]

partial = "default"

## 采集间隔
# interval = "30s"

## 追加标签（可选）
# labels = { env="production", team="devops" }

[instances.alerting]
for_duration = 0
repeat_interval = "5m"
repeat_number = 3
# disabled = false
# disable_recovery_notification = false
