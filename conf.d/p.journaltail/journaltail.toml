## 一个 instance = 一组 filter + 一个 severity
## 需要不同严重级别？配多个 instance 即可
## ===== 最小可用示例（30 秒跑起来）=====
## 1) filter_include 填你的关键字（支持 glob + /regex/）
## 2) severity 设为 Warning 或 Critical
## 3) Linux 上直接生效（依赖 journalctl）
## 例子：
## filter_include = ["*Out of memory*", "/(?i)panic|segfault/"]
## [instances.match]
## severity = "Warning"
## 常见误区：
## - 仅支持 Linux（依赖 journalctl）
## - filter_include 不能为空
## - 一条 include 规则写成 /.../ 才是正则，否则按 glob 处理

## 示例1：常规异常日志 → Warning
[[instances]]
## journalctl 原生预过滤（性能最好，优先推荐）
## units：按 systemd 单元名过滤（可多个）
# units = ["nginx", "sshd", "docker"]

## priority：按日志级别过滤
##   单值："err"
##   范围："emerg..err"
##   数字："0..3"
# priority = "emerg..err"

## 行级过滤（在原生预过滤之后执行）
## include 规则是 OR：任一规则命中即算匹配
## 支持 glob + 正则混用：
##   glob 示例：*Out of memory*
##   正则示例：/(?i)oom|segfault/
filter_include = ["*Out of memory*", "*nf_conntrack: table full*"]
## exclude 为排除规则（优先级高于 include）
# filter_exclude = ["*expected*"]

## 告警描述中最多展示多少条命中日志（默认 10）
max_lines = 10

## journalctl 执行超时（默认 30s）
timeout = "30s"

## Gather interval
interval = "30s"

[instances.match]
severity = "Warning"
# title_rule = "[check] [target]"

[instances.alerting]
for_duration = 0
repeat_interval = "5m"
repeat_number = 3

## 示例2：致命错误 → Critical（独立 instance，独立告警）
# [[instances]]
# filter_include = ["*kernel panic*", "/(?i)segfault|oom.killer/"]
# interval = "30s"
# [instances.match]
# severity = "Critical"
# [instances.alerting]
# repeat_interval = "1m"
# repeat_number = 10
